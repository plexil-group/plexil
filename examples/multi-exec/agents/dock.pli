;; File: $SVNROOT/examples/multi-exec/agents/dock.pli

(plexil-plan
  ;; The "dock" sits and waits for requests to dock from particular rovers,
  ;; and can handle multiple rovers (4 bays?, more?)
  ;;    request := rover-id[0] action(1=doc, ?=un-dock)[2] urgency(not used)[3]
  ;;   response := bay[0] rover[1] dist(ft][2] speed(ft/sec)[3] angle(deg)[4] time(sec)[5]
  ;; A "rover" requests docking information periodically until the dock responds,
  ;; after which the dock periodically broadcasts the telemetry (response) to the
  ;; rover (which it is expected follow as closely as it can).
  ;; After the rover has docked, both the rover and dock execute their own post
  ;; docking procedures, exchanging docking done message, and opening their inner
  ;; hatches.  Eventually, the rover un-docks and departs, freeing up the bay.
  ;;
  ;; The dock has N bays.  If one or more have been requested, then we loop through
  ;; the bays sending "sensed" telemetry related to the rover assigned to the bay
  ;; in question (i.e., dist, angle, speed).  Telemetry is pushed until docking is
  ;; achieved, then post-docking procedures/checks are run, finally the dock hatch
  ;; is opened.  After some time, everything is reverse, and eventually, the bay
  ;; is once again free.
  (concurrently "wait-for-docking-request"
    (variables
      (string "name" "dock")             ;agent name
      (real-array "times" 3)             ;start-time(sec)[0] now(sec)[1] then(sec)[2]
      (integer "period" 2)               ;periodicity of update cycles
      (real "initial-distance" 30)       ;initial distance from dock to rover
      (real-array "speeds" 3 2 1 .2)     ;initial(ft/sec)[0] intermediate(ft/sec)[1] final(ft-sec)[2]
      (real-array "bay1" 6 1 0 0 0 0 0)  ;bay-id[0], rover-id[1], dist(ft)[2], speed(ft/sec)[3], action[4], time(sec)[5]
      (real-array "bay2" 6 2 0 0 0 0 0)
      (real-array "bay3" 6 3 0 0 0 0 0)
      (real-array "bay4" 6 4 0 0 0 0 0))
    (invariant-condition (not (finished "QuitCommand")))
    ;; Record the start time of this run
    (assignment (array-element "times" 0) (lookup-now "time"))
    ;; Announce that we are up and running
    (command "print" "\n\n[" (stringvar "name") "] is up and running...\n\n")
    ;; (1) wait for a docking request, and when one is received, register it with
    ;;     the telemetry loop (so that it will be appropriately serviced)
    (sequence "docking-request"
      (variables (real "rover-id"))
      (repeat-condition true)           ;always open for business
      (on-command "docking-request" ((real-array "request" 3)) ;rover-id[0] action(1=dock,0=un-dock)[1] urgency(unused)[2]
        (sequence "handle-request"
          (assignment (array-element "times" 1) (- (lookup-now "time") (array-element "times" 0)))
          (command "print" "\n[" (stringvar "name") " (" (array-element "times" 1) ")] recv: " (arrayvar "request"))
          (assignment (realvar "rover-id") (array-element "request" 0)) ;grab the rover-id
          ;; If this is an un-docking request, record it
          (try "request-type"
            (action "handle-un-docking-request"
              (skip-condition (= 1 (array-element "request" 1))) ;action(1=dock,0=un-dock)
              ;; This is an un-docking request, so now find which bay it applies to and update the record
              (try "update-bay-record"
                (action "un-dock-from-bay1"
                  (skip-condition (not (= 1 (array-element "bay1" 0))))
                  (assignment (array-element "bay1" 4) (array-element "request" 1)))
                (action "un-dock-from-bay2"
                  (skip-condition (not (= 1 (array-element "bay2" 0))))
                  (assignment (array-element "bay2" 4) (array-element "request" 1)))
                (action "un-dock-from-bay3"
                  (skip-condition (not (= 1 (array-element "bay3" 0))))
                  (assignment (array-element "bay3" 4) (array-element "request" 1)))
                (action "un-dock-from-bay4"
                  (skip-condition (not (= 1 (array-element "bay4" 0))))
                  (assignment (array-element "bay4" 4) (array-element "request" 1)))))
            (action "handle-docking-request"
              ;; If this is a docking request, assign it to the first open bay (what about no bays open?)
              (skip-condition (= 0 (array-element "request" 1))) ;action(1=dock,0=un-dock)
              (try "assign-rover-to-bay"
                (action "use-bay1"
                  (skip-condition (not (= 0 (array-element "bay1" 1))))
                  (library-call-node (call "setup-bay" (alias "bay" (arrayvar "bay1")))))
                (action "use-bay2"
                  (skip-condition (not (= 0 (array-element "bay2" 1))))
                  (library-call-node (call "setup-bay" (alias "bay" (arrayvar "bay2")))))
                (action "use-bay3"
                  (skip-condition (not (= 0 (array-element "bay3" 1))))
                  (library-call-node (call "setup-bay" (alias "bay" (arrayvar "bay3")))))
                (action "use-bay4"
                  (skip-condition (not (= 0 (array-element "bay4" 1))))
                  (library-call-node (call "setup-bay" (alias "bay" (arrayvar "bay4")))))))))))
    ;; (2) the telemetry/status loop spins and services any/all registered docking
    ;; requests every "period" seconds
    (sequence "update-bays"
      (repeat-condition true)
      (assignment (array-element "times" 1) (- (lookup-now "time") (array-element "times" 0)))
      (command "print" "\n\n[" (stringvar "name") " (" (array-element "times" 1) ")]")
      (library-call-node (call "update-bay" (alias "bay" (arrayvar "bay1"))))
      (library-call-node (call "update-bay" (alias "bay" (arrayvar "bay2"))))
      (library-call-node (call "update-bay" (alias "bay" (arrayvar "bay3"))))
      (library-call-node (call "update-bay" (alias "bay" (arrayvar "bay4"))))
      (assignment (array-element "times" 2) (array-element "times" 1)) ;remember when the last cycle finished
      (wait-with-tolerance (- (intvar "period") (mod (lookup-now "time") 1)) .05 "Wait"))
    ;; Quit when asked to
    (action "QuitCommand"
      (on-message "Quit"
        (command "print" "[" (stringvar "name") "] recv: Quit (quitting)\n\n")))))

;; EOF
