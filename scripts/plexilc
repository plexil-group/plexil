#!/bin/sh
# Generalized compiler driver for Plexil source files

# Copyright (c) 2006-2020, Universities Space Research Association (USRA).
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Universities Space Research Association nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY USRA ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL USRA BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#
# Usage:
#    plexilc [options] <source-file>
#
#  The type of source file given is partly identified by its extension:
#
#    Standard Plexil plans        : .plp, .ple
#    Extended Plexil (XML) plans  : .epx
#    Plexilisp plans and scripts  : .pli
#    Plexil simulator scripts     : .pst
#
#  The default (and required) output file extensions are:
#
#    Plexil plans (XML)           : .plx
#    Plexil scripts (XML)         : .psx
#

usage ()
{
    echo "Usage: $(basename "$0") [options] file..."
    echo ' Compile Plexil plans or simulator scripts to XML'
    echo 'Options:'
    echo '  -h, -help, --help       Print this help and exit'
    echo '  -v, -version            Print translator version and exit'
    echo '  -c, -check              Run static checker on output'
    echo '                          (plan files only)'
    echo '  -d, -debug              Print debug information to stderr'
    echo '                          (.plp, .ple files only)'
    echo '  -o, -output <outfile>   Write translator output to <outfile>'
    echo '                          (ignored for .pli files)'
    echo '  -q, -quiet              Parse files quietly'
    echo '  -I <directory>          Include directory'
    echo '                          (.plp files only)'
    echo '  -e, -exit-on-failure    If compillation of any file fails, exit'
    echo '                          immediately'
    echo 'Not all options are supported for all file formats.'
    echo
    echo 'Recognized extensions are:'
    echo '  .epx - Extended Plexil XML plan'
    echo '  .ple - Plexil plan'
    echo '  .plp - Plexil plan with preprocessing'
    echo '  .pli - Plexilisp plan or simulation script'
    echo '  .pst - Plexilscript simulation script'
}

if [ -z "$PLEXIL_HOME" ]
then
    echo 'Error: Please set environment variable PLEXIL_HOME' >&2
    echo "to the full pathname of your 'plexil' or 'trunk' directory." >&2
    exit 1
fi

if [ -n "$JAVA_HOME" ]
then
    JAVA="$JAVA_HOME"/bin/java
    if [ ! -e "$JAVA" ]
    then
        echo "Error: no Java runtime found at $JAVA_HOME" >&2
        echo 'Please set JAVA_HOME to an existing Java runtime,' >&2
        echo 'or install a Java runtime environment.' >&2
        exit 1
    fi
else
    JAVA="$(command -v java)"
    if [ -z "$JAVA" ]
    then
        echo "Error: no Java runtime in path $PATH" >&2
        echo 'Either set PATH to include a Java runtime,' >&2
        echo 'set JAVA_HOME to a Java runtime,' >&2
        echo 'or install a Java runtime environment.' >&2
        exit 1
    fi
fi

JARS_DIR="$PLEXIL_HOME"/jars
ANTLR_RUNTIME_JAR=antlr-3.5.2-complete-no-st3.jar

# Commands to execute
plexil_checker="$PLEXIL_HOME/scripts/checkPlexil"

generate_output_fname()
{
    in_ext="$(expr "$1" : '.*\.\([a-z][a-z][a-z]\)$')"
    case "$in_ext" in
        ( ple | pli | plp | epx )
        echo "$1" | sed -e "s/$in_ext$/plx/"
        ;;

        pst )
            echo "$1" | sed -e "s/$in_ext$/psx/"
            ;;
        * )
            echo "Error: Unrecognized filename extension \"$in_ext\" for $1" >&2
            echo 'Supported extensions are: epx ple pli plp pst' >&2
            if [ -n "${exit_on_fail}" ]
            then
                exit 1
            fi
            ;;
    esac
}

std_plexil_compiler()
{
    "$JAVA" -classpath "$JARS_DIR/PlexilCompiler.jar:$JARS_DIR/$ANTLR_RUNTIME_JAR:$JARS_DIR/nanoxml.jar:$JARS_DIR/saxon.jar" plexil.Compiler ${debug:+--debug} -o "$output" "$1"
}

compile_std_plexil()
{
    # Plexil plan
    if [ -n "$quiet" ]
    then
        std_plexil_compiler "$1" > /dev/null 2>&1
    else 
        std_plexil_compiler "$1"
    fi
    status=$?
    if [ $status -ne 0 ]
    then
        echo "Error: Standard Plexil compilation of $1 failed." >&2
        if [ -n "${exit_on_fail}" ]
        then
            exit $status
        fi
    fi
}

plexilisp_compiler()
{
    EMACS="${EMACS-"$(command -v emacs)"}"
    if [ -z "$EMACS" ]
    then
        echo 'Error: emacs not found. Cannot compile Plexilisp.' >&2
        if [ -n "${exit_on_fail}" ]
        then
            exit 1
        fi
    fi
    "$EMACS" --batch --no-site-file --load "$PLEXIL_HOME"/compilers/plexilisp/plexil.el "$1" --eval '(plexil)'
}

compile_plexilisp()
{
    # Plexilisp plan/script
    if [ -n "$quiet" ]
    then
        plexilisp_compiler "$1" > /dev/null 2>&1
    else
        plexilisp_compiler "$1"
    fi

    # Translator can fail silently without producing a .plx file.
    # If translator generates a plan, move it to the desired location.
    actual_output="$(generate_output_fname "$1")"
    if [ ! -r "$actual_output" ]
    then
        echo "Error: Plexilisp translation of $1 failed." >&2
        if [ -n "${exit_on_fail}" ]
        then
            exit 1
        fi
    fi

    if [ "$output" != "$actual_output" ]
    then
        /bin/mv "$actual_output" "$output"
    fi

    # Delete turds left behind by Plexilisp translator
    turd_base="$(echo "$1" | sed -e 's|.pli$|.epx|')"
    /bin/rm -f "$turd_base" "$turd_base".last
}

compile_ext_plexil()
{
    # Extended Plexil XML plan
    "$PLEXIL_HOME"/scripts/eplexil "$1" "$output"
    status=$?
    if [ $status -ne 0 ]
    then
        echo "Error: Extended Plexil translation of $1 failed." >&2
        if [ -n "${exit_on_fail}" ]
        then
            exit $status
        fi
    fi
}

compile_plexilscript()
{
    # Plexilscript
    "$JAVA" -classpath "$JARS_DIR/plexilscript.jar:$JARS_DIR/antlr.jar" plexilscript.PlexilScriptParse < "$1" > "$output"
    status=$?
    if [ $status -ne 0 ]
    then
        echo "Error: compilation of $1 failed." >&2
        if [ -n "${exit_on_fail}" ]
        then
            exit $status
        fi
    fi
}

compile_plp()
{
    # Standard Plexil w/ preprocessing
    ple_fname="$(echo "$1" | sed -e 's|.plp$|.ple|')"
    # shellcheck disable=SC2086
    "$PLEXIL_HOME"/scripts/plexilpp $pp_args -o "$ple_fname" "$1"
    status=$?
    if [ $status -ne 0 ]
    then
        echo "Error: Preprocessing of $1 failed." >&2
        if [ -n "${exit_on_fail}" ]
        then
            exit $status
        fi
    fi

    # Exits if error detected
    compile_std_plexil "$ple_fname"

    # Delete preprocessor output file
    /bin/rm -f "$ple_fname"

    return 0
}

compile_argument()
{
    if [ ! -r "$1" ]
    then
        echo "Error: file $1 does not exist or is not readable" >&2
        if [ -n "${exit_on_fail}" ]
        then
            exit 1
        fi
    fi

    output="${output:-"$(generate_output_fname "$1")"}"

    # Select translator for this file based on extension
    in_ext="$(expr "$1" : '.*\.\([a-z][a-z][a-z]\)$')"

    case "$in_ext" in
        epx )
            compile_ext_plexil "$1"
            ;;
        
        ple )
            compile_std_plexil "$1"
            ;;
        
        pli )
            compile_plexilisp "$1"
            ;;
        
        plp )
            compile_plp "$1"
            ;;

        pst )
            compile_plexilscript "$1"
            ;;

        * )
            echo "Unable to select compiler for $1" >&2
            usage
            if [ -n "${exit_on_fail}" ]
            then
                exit 2
            fi
            ;;
    esac

    if [ -n "$check" ] && [ "$in_ext" != "pst" ] && [ -r "$output" ]
    then
        $plexil_checker "$output"
    fi
}

# Parse options
while ( echo "$1" | grep -q -e '^-.*' )
do
    case "$1" in
        ( -c | -check )
        check="$1"
        shift
        ;;

        ( -d | -debug )
        debug="$1"
        shift
        ;;

        ( -h | -help | --help )
        usage
        exit 0
        ;;

        -I )
            pp_args="$pp_args $1 $2"
            shift 2
            ;;
        
        ( -o | -output )
        if [ -z "$2" ] || ( echo "$2" | grep -q -e '^-.*' )
        then
            echo "Error: output filename missing for $1 option"
            usage
            exit 2
        fi
        output="$2"
        shift 2
        ;;

        ( -q | -quiet )
        quiet="$1"
        shift
        ;;

        ( -v | -version )
        echo 'plexilc script version 1.3'
        std_plexil_compiler --version
        exit 0
        ;;

        (-e | -exit-on-failiure )
        exit_on_fail="$1"
        shift
        ;;

        *)
            echo "$0: Unrecognized option $1" >&2
            usage
            exit 2
            ;;
    esac
done

# If we got this far, we are expecting a filename to translate
if [ $# -lt 1 ]
then
    echo "Error: no filename supplied." >&2
    usage
    exit 2
fi

# Once we have read the options and know that we have files we can compile each of them sequentialy
while [ $#  -gt 0 ]
do
    if [ -z "$quiet" ]
    then
        echo "Compiling file: $1"
    fi
    if ( echo "$1" | grep -q -e '^-.*' )
    then
        compile_argument "./$1"
    else
        compile_argument "$1"
    fi
    shift
done

exit 0
