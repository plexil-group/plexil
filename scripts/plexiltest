#! /bin/sh -e

# Copyright (c) 2006-2021, Universities Space Research Association (USRA).
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#     * Neither the name of the Universities Space Research Association nor the
#       names of its contributors may be used to endorse or promote products
#       derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY USRA ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL USRA BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# TODO:
#  - Robustify more against pathnames with spaces:
#   Issue is options with pathnames, e.g. -p, -L

guess_plexil_home()
{
    # This script file is expected to be in $PLEXIL_HOME/script
    cd "$(dirname "$(dirname "$(command -v "$0")")")" && pwd -P
}

if [ -z "$PLEXIL_HOME" ]
then
    PLEXIL_HOME="$(guess_plexil_home)"
    export PLEXIL_HOME
    echo "Defaulting PLEXIL_HOME to $PLEXIL_HOME"
fi

if [ ! -r "$PLEXIL_HOME/scripts/plexil-setup.sh" ]
then
    echo "$(basename "$0"): Environment variable PLEXIL_HOME is set incorrectly." >&2
    echo 'Please set it to the full pathname of the PLEXIL source directory' >&2
    exit 1
fi

export PLEXIL_HOME
# shellcheck source=./plexil-setup.sh
. "$PLEXIL_HOME"/scripts/plexil-setup.sh

usage()
{
    cat <<EOF
Usage:
        plexiltest -p <plan> [-s <script file>] [-d <debug file>] [-L <library dir>]* [-l <library>]* [-v [-h <hostname>] [-n <portnumber>] [-b]] [-ch]
For more options enter 'plexiltest -help'
EOF
}

help()
{
    cat <<EOF
Usage:
        plexiltest -p <plan> [-s <script file>] [-d <debug file>] [-L <library dir>]* [-l <library>]* [-v [-h <hostname>] [-n <portnumber>] [-b]] [-ch]

Options:

 -help 
	displays this message
 -p | -plan <plan> 
	specify PLEXIL plan (required) 
 -s | -script <script> 
	specifies a script file
 -d | -debug <file name> 
	debug file (default is Debug.cfg)
 -L | -libraryPath <directory name>
	specifies a directory for finding plan library files
 -q | -quiet 
	Minimize output
 -v | -viewer 
	starts the Plexil Viewer
 -h | -hostname <name> 
	Name of remote host where Viewer is running
 -n | -port <number> 
	Port number to use for Viewer
 -b | -blocking 
	enables breakpoints in Viewer
 -ch | -check 
	runs the PLEXIL static checker prior to executing plan
 -l | -library <file name>
	specifies a plan library (.plx file)
 -? | -help 
	shows this message of options
 -a | -autorun 
	Runs the specified plan immediately at Viewer startup 
 --for-viewer 
	Runs the exec with the supplied options, without checking them, and without starting the Viewer. 
	Intended for use by the Plexil Viewer or other scripts.
EOF
}

# Source command parsing helper functions
# shellcheck source=./script-utils.sh
. "$PLEXIL_HOME"/scripts/script-utils.sh

summarize()
{
    echo "Running executive from $PLEXIL_HOME"
    echo "  Plan:           $plan_nm"
    echo "  Script:         $script_name"
    if [ -n "$library_dirs" ]
    then
        echo "  Library path:   $library_dirs"
    fi
    if [ -n "$libraries" ]
    then
        echo "  Libraries:      $libraries"
    fi
    if [ -n "$host_in" ]
    then
        echo "  Viewer host:    $host_in"
    fi
    if [ -n "$port_in" ]
    then
        echo "  Viewer port:    $port_in"
    fi
    echo
}

# If user has specified a program to run (e.g. plexilfive), use it.
if [ -n "$PLEXIL_EXECUTABLE" ]
then
    prog="$PLEXIL_EXECUTABLE"
elif [ -f "$PLEXIL_HOME/bin/TestExec" ] &&  [ -x "$PLEXIL_HOME/bin/TestExec" ]
then
    # Use the installed TestExec
    prog="$PLEXIL_HOME/bin/TestExec"
elif [ -f "$PLEXIL_HOME/src/apps/TestExec/TestExec" ] && [ -x "$PLEXIL_HOME/src/apps/TestExec/TestExec" ]
then
    # Use the built-but-not-yet-installed TestExec
    prog="$PLEXIL_HOME/src/apps/TestExec/TestExec"
else
    echo "$(basename "$0"): TestExec executable not found, aborting" >&2
    exit 1
fi

plexil_check_prog "$prog"

quiet=""
plan_nm="" 
plan_cmd="" 
script_name="" 
script_cmd="" 
libraries="" 
library_dirs=""
debug_cmd=""
check=""
auto_run_cmd=""

if [ ! "$1" ]
then
    usage
    exit 1
fi

while [ -n "$1" ] 
do
    save="$1"
    case "$1" in
        -a | -autorun )
            auto_run_cmd="$1";;

        -b | -blocking )
            block="$1";;        #enable viewer break point      

        -ch | -check )
            check="$1";;
        
        -d | -debug )
            validate_file "$1" "$2"
            debug_cmd="-d $2"
            shift
            ;;

        --for-viewer)
            automate="$1";;

        -h )
            # Is it a help request or a host name?
            if [ -z "$2" ]
            then
                # Help request
                help
                exit 0
            fi
            validate_host "$1" "$2"
            host_in="-h $2"       #viewer host name
            shift
            ;;
        
        -hostname )
            validate_host "$1" "$2"
            host_in="-h $2"       #viewer host name
            shift
            ;;
        
        -help | --help )
            help
            exit 0;;

        -L | -libraryPath )
            shift
            if [ -z "$1" ]
            then
                echo "$(basename "$0"): missing directory name for $save option" >&2
                usage
                exit 2
            elif [ ! -r "$1" ] || [ ! -d "$1" ]
            then
                echo "$(basename "$0"): $1 is not a readable directory." >&2
                exit 1
            else
                library_dirs="$library_dirs$1 "
                lib_dirs_cmd="$lib_dirs_cmd-L $1 "
            fi;;
        
        -l | -library )
            validate_file "$1" "$2"
            libraries="$libraries -l $2"
            lib_cmd="$lib_cmd-l $2 "
            shift
            ;;

        -n | -port )
            validate_port "$1" "$2"
            port_in="$2"
            port_cmd="-n $2"      #viewer port
            shift
            ;;
        
        -p | -plan )
            validate_file "$1" "$2"
            plan_nm="$2"
            plan_cmd="-p $2"
            shift
            ;;

        -q | -quiet )
            quiet="$1";;
        
        -s | -script )
            validate_file "$1" "$2"
            script_name="$2"
            shift
            ;;
        
        -v | -viewer )
            viewer="$1";;       #viewer listener enabled

        -? )
            echo "$(basename "$0"): unrecognized option $1" >&2
            usage
            exit 2;;
    esac
    shift
done

if [ -n "$automate" ]
then
    # Just Do It - presume caller knows what it's doing.
    # We do not expect a local Viewer to use the -h option.
    if [ -z "$plan_nm" ]
    then
        echo "$(basename "$0"): -p option is required." >&2
        usage
        exit 2
    fi
    
    if [ -z "$script_name" ]
    then
        echo "$(basename "$0"): -s option is required." >&2
        usage
        exit 2
    fi
    
    if [ -n "$check" ]
    then
        checker
    fi
    if [ -z "$quiet" ]
    then
        summarize
    fi

    script_cmd="-s $script_name"

    echo "RUN_TE_PID$$"

    # shellcheck disable=SC2086
    # The unquoted expansions are deliberate
    exec "$prog" $plan_cmd $script_cmd $lib_cmd $lib_dirs_cmd $debug_cmd $viewer $port_cmd $block $quiet
fi

# Check Viewer options
if [ -z "$viewer" ]
then
    # No local Viewer
    if [ -z "$host_in" ]
    then
        # Check local port, if supplied
        if [ -n "$port_in" ]
        then
            if list_ports_in_use | grep -qv "\<${port_in}\>"
            then
                echo "$(basename "$0"): No Viewer is listening on local port $port_in. Exiting." >&2
                exit 1
            fi
        fi
    elif [ -z "$port_in" ]
    then
        echo "$(basename "$0"): Viewer host $host_in specified, but no port was supplied." >&2
        usage
        exit 2
    fi
    # TODO: Bounds check port number
elif [ -n "$host_in" ]
then
    echo "$(basename "$0"): -h (remote Viewer host) and -v (local Viewer) may not be combined." >&2
    usage
    exit 2
else
    # Local Viewer requested
    if [ -z "$port_in" ]
    then
        # Find open local port
        port_in="$(find_open_port)"
        if [ -z "$port_in" ]
        then
            echo "Unable to find an open local port for Viewer communications. Exiting." >&2
            exit 1
        fi
        port_cmd="-n $port_in"
    elif list_ports_in_use | grep -q "\<${port_in}\>"
    then
        echo "$(basename "$0"): Port $port_in is in use. Exiting." >&2
        exit 1
    fi
fi

if [ -n "$host_in" ]
then
    host_cmd="-hostname $host_in"
fi

# Run default debug
if [ -z "$debug_cmd" ] && [ -z "$quiet" ] && [ -r "Debug.cfg" ]
then
    debug_cmd="-d Debug.cfg"
fi

# Check plan for errors
if [ -z "$viewer" ] && [ -n "$check" ]
then
    checker
fi

# The plan file's extension, used to compute guessed script name.
ext=".$(echo "$plan_nm" | awk -F. '{print $2}')"

# If no more arguments, or next argument -l, check for candidate scripts.
# Otherwise, next argument must be script.

if [ -n "$script_name" ]
then
    if [ ! -f "$script_name" ]
    then
        echo "$(basename "$0"): Script $script_name does not exist." >&2
        exit 1
    elif [ ! -r "$script_name" ]
    then
        echo "$(basename "$0"): Script file $script_name is not readable." >&2
        exit 1
    fi
else
    # Attempt to guess based on plan name
    script_candidate="$(basename "$plan_nm" "$ext")".psx
    if [ -e "$script_candidate" ]
    then
        script_name="$script_candidate"
    elif [ -e "scripts/$script_candidate" ]
    then
        script_name="scripts/$script_candidate"
    elif [ -e "../scripts/$script_candidate" ]        
    then
        script_name="../scripts/$script_candidate"
    fi
fi

if [ -z "$script_name" ]
then
    warn 'No simulation script specified; using empty script.' >&2
    script_name="$PLEXIL_HOME/examples/empty.psx"
fi

script_cmd="-s $script_name"

# separate command-line from plexiltest output
echo

# Print summary if desired
if [ -z "$quiet" ] && [ -z "$viewer" ]
then
    summarize
fi

if [ -n "$viewer" ]
then
    # *** FIXME ***
    # Launch the viewer, which will in turn invoke this script again with the automate flag
    # The unquoted expansions are deliberate
    # shellcheck disable=SC2086
    exec plexil -plexiltest $plan_cmd $script_cmd $lib_dirs_cmd $lib_cmd $debug_cmd $host_cmd $port_cmd $check $block $auto_run_cmd
else
    # User doesn't want viewer
    # shellcheck disable=SC2086
    # The unquoted expansions are deliberate
    exec "$prog" $plan_cmd $script_cmd $lib_dirs_cmd $lib_cmd $debug_cmd $block
fi
