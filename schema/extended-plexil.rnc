# * Copyright (c) 2006-2020, Universities Space Research Association (USRA).
# *  All rights reserved.
# *
# * Redistribution and use in source and binary forms, with or without
# * modification, are permitted provided that the following conditions are met:
# *     * Redistributions of source code must retain the above copyright
# *       notice, this list of conditions and the following disclaimer.
# *     * Redistributions in binary form must reproduce the above copyright
# *       notice, this list of conditions and the following disclaimer in the
# *       documentation and/or other materials provided with the distribution.
# *     * Neither the name of the Universities Space Research Association nor the
# *       names of its contributors may be used to endorse or promote products
# *       derived from this software without specific prior written permission.
# *
# * THIS SOFTWARE IS PROVIDED BY USRA ``AS IS'' AND ANY EXPRESS OR IMPLIED
# * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# * DISCLAIMED. IN NO EVENT SHALL USRA BE LIABLE FOR ANY DIRECT, INDIRECT,
# * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
# * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
# * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
# * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# This schema extends Core PLEXIL with syntactic sugar: convenient forms 
# that are translated into Core PLEXIL for execution (see translate.xsl).

default namespace = ""
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"

include "plexil-base.rnc"
# Elements
Action =
  Node
  | Concurrence
  | Sequence
  | CheckedSequence
  | UncheckedSequence
  | Try
  | If
  | While
  | For
  | OnCommand
  | OnMessage
  | Wait
  | SynchronousCommand
BooleanExpression =
  LogicalOperator
  | Equality
  | NumericComparison
  | KnownTest
  | BooleanVariable
  | BooleanValue
  | Finished
  | IterationEnded
  | Executing
  | Waiting
  | Inactive
  | Succeeded
  | IterationSucceeded
  | Failed
  | Interrupted
  | IterationFailed
  | Skipped
  | InvariantFailed
  | PreconditionFailed
  | PostconditionFailed
  | ParentFailed
  | MessageReceived
DeclaredVariable =
  IntegerVariable
  | RealVariable
  | BooleanVariable
  | StringVariable
  | DateVariable
  | DurationVariable
  | ArrayVariable
  | ArrayElement
LookupGroup = LookupOnChange | LookupNow | Lookup
Name = element Name { GeneralizedStringExpression, SourceLocators }
NumericExpression =
  ArithmeticOperator
  | IntegerVariable
  | RealVariable
  | IntegerValue
  | RealValue
  | DateVariable
  | DateValue
  | DurationVariable
  | DurationValue
  | NodeTimepointValue
  | #  read operations for arrays
    ArraySize
  | ArrayMaxSize
Value =
  IntegerValue
  | RealValue
  | BooleanValue
  | StringValue
  | DateValue
  | DurationValue
# Schema types
AtomicTypeValues =
  "Integer" | "Real" | "Boolean" | "String" | "Date" | "Duration"
ParameterTypeValues =
  "Integer"
  | "Real"
  | "Boolean"
  | "String"
  | "Date"
  | "Duration"
  | "Any"
# Extensions to Core Plexil
DurationVariable = element DurationVariable { xsd:NCName }
DateVariable = element DateVariable { xsd:NCName }
DateValue = element DateValue { xsd:string }
DurationValue = element DurationValue { xsd:string }
# Node clauses, which can occur in any action.
NodeClauses =
  NodeId?
  | element Comment { xsd:string }?
  | StartCondition?
  | RepeatCondition?
  | PreCondition?
  | PostCondition?
  | InvariantCondition?
  | EndCondition?
  | SkipCondition?
  | element Priority { xsd:nonNegativeInteger }?
  | Interface?
  | VariableDeclarations?
# Sequence forms
SequenceType = NodeClauses*, Action*
# Actions are performed concurrently.  This is just a List Node.
Concurrence = element Concurrence { SequenceType, SourceLocators }
# Each action in the sequence is performed in the given order.  If
# one fails, the Sequence form terminates with failure.
Sequence = element Sequence { SequenceType, SourceLocators }
# Each action in the sequence is performed in the given order.  If
# one fails, the CheckedSequence form terminates with failure.
CheckedSequence =
  element CheckedSequence { SequenceType, SourceLocators }
# Like Sequence, except the actions are not checked for success.
# They will all be executed
UncheckedSequence =
  element UncheckedSequence { SequenceType, SourceLocators }
# Each action in the sequence is performed in turn, until one of
# them succeeds; the rest are ignored.  The Try form fails if and
# only if all its actions fail.
Try = element Try { SequenceType, SourceLocators }
# Conditionals and loops

# If statement with optional ElseIf and Else.
If =
  element If {
    NodeClauses*,
    element Condition { GeneralizedBooleanExpression },
    element Then { Action },
    element ElseIf {
      element Condition { GeneralizedBooleanExpression },
      element Then { Action }
    }*,
    element Else { Action }?,
    SourceLocators
  }
# A classic while loop
While =
  element While {
    NodeClauses*,
    element Condition { GeneralizedBooleanExpression },
    element Action { Action },
    SourceLocators
  }
# A For loop.  First a variable is declared (it must be numeric).
# Next is a boolean expression that determines when to keep the loop
# going.  Next is a numeric expression used to update the variable
# (it is typically a function of the variable).  Finally, actions
# to execute.
For =
  element For {
    NodeClauses*,
    element LoopVariable { DeclareVariable },
    element Condition { GeneralizedBooleanExpression },
    element LoopVariableUpdate { GeneralizedNumericExpression },
    element Action { Action },
    SourceLocators
  }
# Node Predicates
IterationSucceeded = element IterationSucceeded { node-reference }
Interrupted = element Interrupted { node-reference }
IterationFailed = element IterationFailed { node-reference }
InvariantFailed = element InvariantFailed { node-reference }
PreconditionFailed = element PreconditionFailed { node-reference }
ParentFailed = element ParentFailed { node-reference }
# Support for message passing between executives

# Deprecated
MessageReceived =
  element MessageReceived {
    GeneralizedStringExpression, SourceLocators
  }
OnCommand =
  element OnCommand { NodeClauses*, Name, Action?, SourceLocators }
OnMessage =
  element OnMessage {
    NodeClauses*,
    element Message { GeneralizedStringExpression },
    Action?,
    SourceLocators
  }
# Specialized actions

# Wait a specified duration, with optional tolerance for the time reading
Wait =
  element Wait {
    NodeClauses*,
    element Units { GeneralizedNumericExpression },
    Tolerance?,
    SourceLocators
  }
# Command action that waits for its return value or status handle
SynchronousCommand =
  element SynchronousCommand {
    NodeClauses*,
    element Timeout { GeneralizedNumericExpression }?,
    Tolerance?,
    Command,
    SourceLocators
  }
# Generic lookup form
Lookup = element Lookup { Name, Tolerance?, Arguments?, SourceLocators }
