if ! $(IdlRules_INCLUDED) {

# *** To do:
#  - move generated stub files out of IDL source dir (to facilitate read-only source dir)
#  - find way to silence "using independent target" warnings for unused generated files
#  - find way to auto-delete unneeded generated files

# N.B.  Don't grist header files (*.h, *.inl) because they are globally visible!!

# Not quite sure where these variable defs should go

STUBBER ?= $(TAO_ROOT)/TAO_IDL/tao_idl ;

# only warn on names differing only by case (as opposed to hard error)
STUBBERFLAGS ?= -Cw ;

# IdlClientStubs fooC.cpp : foo.idl
#
# Expects IDL file argument to be a single file name
#
rule IdlClientStubs 
{
  MakeLocate $(<) : $(LOCATE_TARGET) ;
  SEARCH on $(<) = $(SEARCH_SOURCE) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;

  local _target = [ FGristFiles $(<) ] ;
  local _destHdr = $(<:S=.h) ;
  local _destInl = $(<:S=.inl) ;
  local _products = $(_target) $(_destHdr) $(_destInl) ;
  MakeLocate $(_products) : $(LOCATE_TARGET) ;

  local _stubberProducts = [ FIdlStubberProducts $(>) ] ;
  RunIdlStubber $(_stubberProducts) : $(>) ;

  IdlMv $(_products) : $(_stubberProducts[1-3]) ;

  Includes $(_target) : $(_destHdr) $(_destInl) ;

  TEMPORARY $(_stubberProducts) ;
  LocalClean clean : $(_products) $(_stubberProducts) ;
}


# IdlServantSkeletons fooS.cpp : foo.idl
#
# Expects IDL file argument to be a single file name
#
rule IdlServantSkeletons
{
  MakeLocate $(<) : $(LOCATE_TARGET) ;
  SEARCH on $(<) = $(SEARCH_SOURCE) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;

  local _servantCpp = [ FGristFiles $(<[2]) ] ;
  local _servantHdr = $(<[2]:S=.h) ;
  local _servantInl = $(<[2]:S=.inl) ;
  MakeLocate $(_servantCpp) $(_servantHdr) $(_servantInl) : $(LOCATE_TARGET) ;

  local _servantTemplateCpp = [ FGristFiles $(<[3]) ] ;
  local _servantTemplateHdr = $(<[3]:S=.h) ;
  local _servantTemplateInl = $(<[3]:S=.inl) ; 
  MakeLocate $(_servantTemplateCpp) $(_servantTemplateHdr) $(_servantTemplateInl) : $(LOCATE_TARGET) ;

  local _stubberProducts = [ FIdlStubberProducts $(>) ] ;
  RunIdlStubber $(_stubberProducts[4-6]) : $(>) ;

  IdlMv $(_products) : $(_stubberProducts[4-6]) ;

  Includes $(_servantCpp) : $(_servantHdr) $(_servantInl) ;
  Includes $(_servantHdr) : $(_servantTemplateHdr) ;
  Includes $(_servantTemplateCpp) : $(_servantTemplateHdr) $(_servantTemplateInl) ;

  TEMPORARY $(_stubberProducts) ;
  LocalClean clean : $(_stubberProducts)
                     $(_servantCpp) $(_servantHdr) $(_servantInl)
                     $(_servantTemplateCpp) $(_servantTemplateHdr) $(_servantTemplateInl) ;
}


# Generate ALL stubs
# AllIdlStubs <C.cpp> <S.cpp> : <IDL file>
#
# Expects IDL file argument to be a single file name
#
rule AllIdlStubs 
{
  MakeLocate $(<) : $(LOCATE_TARGET) ;
  SEARCH on $(<) = $(SEARCH_SOURCE) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;

  # These are the desired output files
  local _clientCpp = [ FGristFiles $(<[1]) ] ;
  local _clientHdr = $(<[1]:S=.h) ;
  local _clientInl = $(<[1]:S=.inl) ;
  MakeLocate $(_clientCpp) $(_clientHdr) $(_clientInl) : $(LOCATE_TARGET) ;

  local _servantCpp = [ FGristFiles $(<[2]) ] ;
  local _servantHdr = $(<[2]:S=.h) ;
  local _servantInl = $(<[2]:S=.inl) ;
  MakeLocate $(_servantCpp) $(_servantHdr) $(_servantInl) : $(LOCATE_TARGET) ;

  # This variable represents the actual locations of the stubber output files
  local _stubberProducts = [ FIdlStubberProducts $(>) ] ;
  RunIdlStubber $(_stubberProducts) : $(>) ;

  IdlMv $(_clientCpp) $(_clientHdr) $(_clientInl) : $(_stubberProducts[1-3]) ;
  IdlMv $(_servantCpp) $(_servantHdr) $(_servantInl) : $(_stubberProducts[4-6]) ;

  Includes $(_clientCpp) : $(_clientHdr) $(_clientInl) ;
  Includes $(_servantCpp) : $(_servantHdr) $(_servantInl) ;
  Includes $(_servantHdr) : $(_servantTemplateHdr) ;

  TEMPORARY $(_stubberProducts) ; 
  LocalClean clean : $(_stubberProducts)
                     $(_clientCpp) $(_clientHdr) $(_clientInl)
                     $(_servantCpp) $(_servantHdr) $(_servantInl) ;
}


#
# Internal rules
#

# Constructs a list of file names generated by the stubber
#
# FIdlStubberProducts foo.idl
#  returns fooC.cpp ... fooS.inl 
# *** all output pathnames are in the current working directory!!
#
rule FIdlStubberProducts 
{
  local _base = $(<:BD=) ;

  local _clientBase = $(_base)C ;
  local _clientCommon = $(<:B=$(_clientBase)) ;

  local _clientCpp = $(_clientCommon:S=.cpp) ;
  local _clientHdr = $(_clientCommon:S=.h) ;
  local _clientInl = $(_clientCommon:S=.inl) ;

  local _servantBase = $(_base)S ;
  local _servantCommon = $(<:B=$(_servantBase)) ;

  local _servantCpp = $(_servantCommon:S=.cpp) ;
  local _servantHdr = $(_servantCommon:S=.h) ;
  local _servantInl = $(_servantCommon:S=.inl) ;

  local _result =
    [ FGristCWDFiles $(_clientCpp) $(_clientHdr) $(_clientInl)
                     $(_servantCpp) $(_servantHdr) $(_servantInl) ] ;

  LOCATE on $(_result) = $(CWD) ;

  return $(_result) ;
}

# Set the files' grist to represent the current working directory relative to the root.
# *** doesn't work when CWD = root!
rule FGristCWDFiles
{
  local _grist = $(SUBDIR_UP:J=!) ;
  if ! $(_grist)
  {
    _grist = $(_top) ;
  }
  return $(<:G=$(_grist)) ;
}

# RunIdlStubber <products> : foo.idl

rule RunIdlStubber 
{
  HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;
  Depends $(<) : $(>) ;
  LocalClean clean : $(<) ;
}

actions RunIdlStubber 
{
  $(STUBBER) $(STUBBERFLAGS) -I$(HDRS) $(>) ;
}

#
# IdlMv <dest.cpp> <dest.h> <dest.inl> : <gen.cpp> <gen.h> <gen.inl>
#
rule IdlMv
{
  Depends $(<) : $(>) ;
}


# assumes /bin/sh or similar
actions IdlMv
{
  if [ $(<[1]) != $(>[1]) ] 
  then 
    $(MV) $(>[1]) $(<[1]) 
    $(MV) $(>[2]) $(<[2]) 
    $(MV) $(>[3]) $(<[3]) 
  fi 
}

IdlRules_INCLUDED = TRUE ;

} # IdlRules_INCLUDED

