/****************************************************************************
 * $Revision: 1.2 $  $Author: reids $  $Date: 2009/01/12 15:54:59 $
 *
 * PROJECT:      Distributed Robotic Agents
 * DESCRIPTION:  
 *
 * (c) Copyright 2001 CMU. All rights reserved.
 * Copyright (c) 2008, Carnegie Mellon University
 *     This software is distributed under the terms of the 
 *     Simplified BSD License (see ipc/LICENSE.TXT)
 ***************************************************************************/

/***************************************************************************
 * INCLUDES
 ***************************************************************************/

#include <assert.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <time.h> // asctime()

#include <iostream>

#include "XDROutputLisp.h"
#include "ParseError.h"
#include "xdrgen.h"

/***************************************************************************
 * GLOBAL VARIABLES AND STATIC CLASS MEMBERS
 ***************************************************************************/

static int outLineNumberG;

/***************************************************************************
 * FUNCTIONS
 ***************************************************************************/

static ostream&
endlCount(ostream& out) {
  outLineNumberG++;
  return out << endl;
}

static const char *
lispTypeName(XDRTypeEnum tenum) {
  switch (tenum) {
    //case T_STRUCT: return "struct"; break;
  case T_ENUM: return "(or integer symbol)"; break;
  case T_STRING: return "string"; break;
  case T_UCHAR: return "character"; break;
  case T_CHAR: return "character"; break;
  case T_UINT: return "(integer 0 *)"; break;
  case T_INT: return "integer"; break;
  case T_BOOL: return "(or nil t)"; break;
  case T_FLOAT: return "single-float"; break;
  case T_DOUBLE: return "double-float"; break;
  default: abort(); /* bad tenum value */
  }
}

static const char *
lispDefaultValue(XDRTypeEnum tenum) {
  switch (tenum) {
    //case T_STRUCT: return "struct"; break;
  case T_ENUM: return "0"; break;
  case T_STRING: return "\"\""; break;
  case T_UCHAR: return "#\\0"; break;
  case T_CHAR: return "#\\0"; break;
  case T_UINT: return "0"; break;
  case T_INT: return "0"; break;
  case T_BOOL: return "nil"; break;
  case T_FLOAT: return "0.0"; break;
  case T_DOUBLE: return "0.0"; break;
  default: abort(); /* bad tenum value */
  }
}



void
XDROutputLisp::setIndentLevel(int newIndentLevel) {
  indentLevel = newIndentLevel;
  indent = string(indentLevel,' ');
}

void
XDROutputLisp::beginSpec(XDRSpecification *spec) {
  outLineNumberG = 1;
  if (DIRECTIVES_GCC == ParsePos::directivesMode) {
    ParsePos::putLineDirective(out, outLineNumberG, outFileName,
			       /* enteringFile = */ true);
    out << endlCount;
  }

  string timeStamp = ctime(&spec->specFileStat.st_mtime);
  // remove trailing newline
  timeStamp = timeStamp.substr(0,timeStamp.length()-1); 

  out << ";; automatically generated by xdrgen from "
      << spec->specFileName << endlCount
      << ";; xdrgen cvs version: " << xdrgenVersionG << endlCount
      << ";; " << spec->specFileName << " last modified: "
      << timeStamp << endlCount << endlCount;

  setIndentLevel(0);
}

void
XDROutputLisp::endSpec(XDRSpecification *spec) {
  /* nothing to do */
}

void
XDROutputLisp::outputFormatDefinition(XDRDeclNode *typeDef) {
  out << "(defconstant " << typeDef->fieldName->val << "_IPC_FORMAT" << endlCount
      << "  (concatenate 'string ";
  ipcFormatter.outputFormat(typeDef,&out);
  out << "))" << endlCount << endlCount;
}

void
XDROutputLisp::beginTypeDef(XDRDeclNode *decl, int index,
			    int numTypeDefs) {
  /* do nothing */
}

void
XDROutputLisp::endTypeDef(XDRDeclNode *decl, int index, int numTypeDefs) {
  outputFormatDefinition(decl);
}

void
XDROutputLisp::beginStructField(XDRDeclNode *decl, int index, int numDecls) {
  /* do nothing */
}

void
XDROutputLisp::endStructField(XDRDeclNode *decl, int index, int numDecls) {
  /* do nothing */
}

void
XDROutputLisp::beginTypeSpec(XDRTypeSpecNode *typeSpec) {
  // do not print out the type spec as a field of a struct if we are not inside
  //   a struct, or if this is the type spec for a struct.
  if (0 == structContextStack.size() || T_STRUCT == typeSpec->type) return;


  if (T_IDENT == typeSpec->type) {
    XDRTypeSpecIdentNode *identNode = (XDRTypeSpecIdentNode *) typeSpec;
    out << indent << getDeclContext()->fieldName->val
	<< "    ;; type: " << identNode->ident->val << endlCount;
  } else if (A_SINGLE != typeSpec->arrayEnum) {
    out << indent << getDeclContext()->fieldName->val
	<< "    ;; type: " << lispTypeName(typeSpec->type);
  } else {
    out << indent << "(" << getDeclContext()->fieldName->val
	<< " " << lispDefaultValue(typeSpec->type) << " :type "
	<< lispTypeName(typeSpec->type)
	<< ")";
    if (T_ENUM == typeSpec->type) {
      out << "    ;; enumerated type";
    }
    out << endlCount;
  }
}

void
XDROutputLisp::endTypeSpec(XDRTypeSpecNode *typeSpec) {
  if (A_SINGLE != typeSpec->arrayEnum) out << endlCount;
}

void
XDROutputLisp::beginStruct(XDRTypeSpecStructNode *structNode) {
  out << "(IPC:IPC_defstruct (" << getTypeDefContext()->fieldName->val
      << ")" << endlCount;
  if (structContextStack.size() >= 2) {
    cerr << ParseError("Can't use anonymous structs with lisp output language",
		       getDeclContext()->fieldName->pos,  /* showToken = */ false);
    exit(EXIT_FAILURE);
  }
  setIndentLevel(indentLevel+2);
}

void
XDROutputLisp::endStruct(XDRTypeSpecStructNode *structNode) {
  //if (0 != structNode->afterDecls) processCode(structNode->afterDecls,0,0);
  out << indent << ")" << endlCount;
  setIndentLevel(indentLevel-2);
}

void
XDROutputLisp::beginEnumSpec(XDRTypeSpecEnumNode *typeEnum) {
  // only output an enum spec if we are outside of a struct
  if (0 != structContextStack.size()) return;

  out << "(defconstant " << getDeclContext()->fieldName->val << "_ENUM #(";
}

void
XDROutputLisp::endEnumSpec(XDRTypeSpecEnumNode *typeEnum) {
  // only output an enum spec if we are outside of a struct
  if (0 != structContextStack.size()) return;

  out << "))" << endlCount;
}

void
XDROutputLisp::processEnum(XDREnumEntryNode *entry, int index,
			     int numEntries) {
  // only output an enum spec if we are outside of a struct
  if (0 != structContextStack.size()) return;

  if (0 != entry->value) {
    cerr << ParseError("Can't use label=value in enum with lisp output language",
		       entry->ident->pos, /* showToken = */ false);
    exit(EXIT_FAILURE);
  }
  out << ":" << entry->ident->val << " ";
}

void
XDROutputLisp::beforeArrayDims(XDRTypeSpecNode *typeSpec) {
  /* do nothing */
}

void
XDROutputLisp::processArrayDim(XDRArrayDimNode *arrayDim, int index,
			       int numArrayDims) {
  // this function spits out array dimensions for a field of a struct.
  //   if we are not inside a struct, do nothing.
  if (0 == structContextStack.size()) return;

  if (index == numArrayDims) {
    // the last var-length dim for a string
    // out << "[]";
  } else if (A_FIXED_ARRAY == getTypeSpecContext()->arrayEnum) {
    out << "[";
    if (0 != arrayDim->maxLength) out << arrayDim->maxLength->val;
    out << "]";
  } else if (A_VAR_ARRAY == getTypeSpecContext()->arrayEnum) {
    out << "<>";
  }
}

#if 0
static int
countNewlines(string s) {
  int count = 0;
  string::size_type pos, searchPos = 0;
  while (string::npos != (pos = s.find('\n', searchPos))) {
    searchPos = pos+1;
    count++;
  }
  return count;
}
#endif

void
XDROutputLisp::processCode(XDRPassThroughCodeNode *code, int index,
			     int numDefs) {
#if 0
  //out << code;

  ParsePos::putLineDirective(out, code->beginPos.lineNumber,
			     code->beginPos.getFileName(),
			     /* enteringFile = */ true,
			     /* portableMode = */ true);
  out << endlCount;

  out << code->getCode();
  outLineNumberG += countNewlines(code->getCode());

  ParsePos::putLineDirective(out, outLineNumberG, outFileName,
			     /* enteringFile = */ false,
			     /* portableMode = */ true);
  out << endlCount;
#endif
}

/***************************************************************************
 * REVISION HISTORY:
 * $Log: XDROutputLisp.cc,v $
 * Revision 1.2  2009/01/12 15:54:59  reids
 * Added BSD Open Source license info
 *
 * Revision 1.1  2002/05/09 01:46:04  trey
 * initial check-in
 *
 *
 ***************************************************************************/
