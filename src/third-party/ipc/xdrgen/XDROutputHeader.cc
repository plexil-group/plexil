/****************************************************************************
 * $Revision: 1.5 $  $Author: reids $  $Date: 2009/01/12 15:54:59 $
 *
 * PROJECT:      Distributed Robotic Agents
 * DESCRIPTION:  
 *
 * (c) Copyright 2001 CMU. All rights reserved.
 * Copyright (c) 2008, Carnegie Mellon University
 *     This software is distributed under the terms of the 
 *     Simplified BSD License (see ipc/LICENSE.TXT)
 ***************************************************************************/

/***************************************************************************
 * INCLUDES
 ***************************************************************************/

#include <assert.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <time.h> // asctime()

#include <iostream>

#include "XDROutputHeader.h"
#include "xdrgen.h"

/***************************************************************************
 * GLOBAL VARIABLES AND STATIC CLASS MEMBERS
 ***************************************************************************/

static int outLineNumberG;

/***************************************************************************
 * FUNCTIONS
 ***************************************************************************/

static ostream&
endlCount(ostream& out) {
  outLineNumberG++;
  return out << endl;
}

void
XDROutputHeader::setIndentLevel(int newIndentLevel) {
  indentLevel = newIndentLevel;
  indent = string(indentLevel,' ');
}

void
XDROutputHeader::beginSpec(XDRSpecification *spec) {
  outLineNumberG = 1;
  if (DIRECTIVES_GCC == ParsePos::directivesMode) {
    ParsePos::putLineDirective(out, outLineNumberG, outFileName,
			       /* enteringFile = */ true);
    out << endlCount;
  }

  string timeStamp = ctime(&spec->specFileStat.st_mtime);
  // remove trailing newline
  timeStamp = timeStamp.substr(0,timeStamp.length()-1); 

  out << "/* automatically generated by xdrgen from "
      << spec->specFileName << endlCount
      << " * xdrgen cvs version: " << xdrgenVersionG << endlCount
      << " * " << spec->specFileName << " last modified: "
      << timeStamp << endlCount
      << " */" << endlCount << endlCount;
  if (outFileName == "") includeGuardName = "stdout";
  else {
    // do some substitutions on the filename to make the include guard
    string::size_type strPos;
    includeGuardName = outFileName;
    // strip directories off the front
    if (string::npos != (strPos = includeGuardName.rfind("/"))) {
      includeGuardName = includeGuardName.substr(strPos+1);
    }
    // replace '.' with '_'
    while (string::npos != (strPos = includeGuardName.find("."))) {
      includeGuardName[strPos] = '_';
    }
  }
  out << "#ifndef INC" << includeGuardName << endlCount
      << "#define INC" << includeGuardName << endlCount
      << endlCount;
  if (LANG_C == lang) {
    out << "#ifndef __xdr_bool" << endlCount
	<< "typedef char bool;" << endlCount
	<< "#define false (0)" << endlCount
	<< "#define true  (1)" << endlCount
	<< "#define __xdr_bool 1" << endlCount
	<< "#endif /* defined(__xdr_bool) */" << endlCount
	<< endlCount;
  }

  setIndentLevel(0);
}

void
XDROutputHeader::endSpec(XDRSpecification *spec) {
  out << endlCount
      << "#endif /* INC" << includeGuardName << " */" << endlCount;

  if (DIRECTIVES_GCC == ParsePos::directivesMode) {
    ParsePos::putLineDirective(out, 2, outFileName,
			       /* enteringFile = */ false);
    out << endlCount;
  }
}

void
XDROutputHeader::outputFormatDefinition(XDRDeclNode *typeDef) {
  out << "#define " << typeDef->fieldName->val << "_IPC_FORMAT ";
  ipcFormatter.outputFormat(typeDef,&out);
  out << endlCount;
  if (LANG_CPLUSPLUS == lang && T_STRUCT == typeDef->typeSpec->type) {
    out << indent << "static const char *getIPCFormat(void) {" << endlCount
	<< indent << "  return " << typeDef->fieldName->val
	<< "_IPC_FORMAT;" << endlCount
	<< indent << "}" << endlCount;
  }
}

void
XDROutputHeader::beginTypeDef(XDRDeclNode *decl, int index,
			    int numTypeDefs) {
  if (T_STRUCT == decl->typeSpec->type
      || T_ENUM == decl->typeSpec->type) out << endlCount;
  if (! (LANG_CPLUSPLUS == lang
	 && (T_STRUCT == decl->typeSpec->type
	     || T_ENUM == decl->typeSpec->type))) {
    out << "typedef ";
  }
}

void
XDROutputHeader::endTypeDef(XDRDeclNode *decl, int index, int numTypeDefs) {
  out << ";" << endlCount;
  if (! (LANG_CPLUSPLUS == lang
	 && T_STRUCT == decl->typeSpec->type)) {
    outputFormatDefinition(decl);
  }
}

void
XDROutputHeader::beginStructField(XDRDeclNode *decl, int index, int numDecls) {
  /* do nothing */
}

void
XDROutputHeader::endStructField(XDRDeclNode *decl, int index, int numDecls) {
  out << ";" << endlCount;
}

void
XDROutputHeader::beginTypeSpec(XDRTypeSpecNode *typeSpec) {
  out << indent << typeSpec->nameOfTypeHeader(lang);
}

void
XDROutputHeader::endTypeSpec(XDRTypeSpecNode *typeSpec) {
  // if (A_VAR_ARRAY == typeSpec->arrayEnum) out << "[]";
}

void
XDROutputHeader::beginStruct(XDRTypeSpecStructNode *structNode) {
  out << " ";
  if (structContextStack.size() < 2) {
    if (LANG_C == lang) out << "_";
    out << getTypeDefContext()->fieldName->val << " ";
  }
  out << "{" << endlCount;
  setIndentLevel(indentLevel+2);
}

void
XDROutputHeader::endStruct(XDRTypeSpecStructNode *structNode) {
  if (LANG_CPLUSPLUS == lang && structContextStack.size() < 2) {
    outputFormatDefinition(getTypeDefContext());
  }
  if (0 != structNode->afterDecls) processCode(structNode->afterDecls,0,0);
  setIndentLevel(indentLevel-2);
  out << indent << "}";
}

void
XDROutputHeader::beginEnumSpec(XDRTypeSpecEnumNode *typeEnum) {
  out << " ";
  if (structContextStack.empty()) {
    if (LANG_C == lang) out << "_";
    out << getTypeDefContext()->fieldName->val << " ";
  }
  out << "{" << endlCount;
  setIndentLevel(indentLevel+2);
}

void
XDROutputHeader::endEnumSpec(XDRTypeSpecEnumNode *typeEnum) {
  setIndentLevel(indentLevel-2);
  out << indent << "}";
}

void
XDROutputHeader::processEnum(XDREnumEntryNode *entry, int index,
			     int numEntries) {
  out << indent << entry->ident->val;
  if (0 != entry->value) {
    out << " = " << entry->value->val;
  }
  if (index < numEntries-1) out << ",";
  out << endlCount;
}

void
XDROutputHeader::beforeArrayDims(XDRTypeSpecNode *typeSpec) {
  bool afterPointer = false;
  if (A_VAR_ARRAY == typeSpec->arrayEnum) {
    if (!afterPointer) out << " ";
    out << "*";
    afterPointer = true;
  }
  if (T_STRING == typeSpec->type) {
    if (!afterPointer) out << " ";
    out << "*";
    afterPointer = true;
  }
  if (! (LANG_CPLUSPLUS == lang
	 && structContextStack.empty()
	 && (T_STRUCT == typeSpec->type
	     || T_ENUM == typeSpec->type))) {
    if (!afterPointer) out << " ";
    out << getDeclContext()->fieldName->val;
  }
}

void
XDROutputHeader::processArrayDim(XDRArrayDimNode *arrayDim, int index,
			       int numArrayDims) {
  if (index == numArrayDims) {
    // the last var-length dim for a string
    // out << "[]";
  } else if (A_FIXED_ARRAY == getTypeSpecContext()->arrayEnum) {
    out << "[";
    if (0 != arrayDim->maxLength) out << arrayDim->maxLength->val;
    out << "]";
  }
}

static int
countNewlines(string s) {
  int count = 0;
  string::size_type pos, searchPos = 0;
  while (string::npos != (pos = s.find('\n', searchPos))) {
    searchPos = pos+1;
    count++;
  }
  return count;
}

void
XDROutputHeader::processCode(XDRPassThroughCodeNode *code, int index,
			     int numDefs) {
  //out << code;

  ParsePos::putLineDirective(out, code->beginPos.lineNumber,
			     code->beginPos.getFileName(),
			     /* enteringFile = */ true,
			     /* portableMode = */ true);
  out << endlCount;

  out << code->getCode();
  outLineNumberG += countNewlines(code->getCode());

  ParsePos::putLineDirective(out, outLineNumberG, outFileName,
			     /* enteringFile = */ false,
			     /* portableMode = */ true);
  out << endlCount;
}

/***************************************************************************
 * REVISION HISTORY:
 * $Log: XDROutputHeader.cc,v $
 * Revision 1.5  2009/01/12 15:54:59  reids
 * Added BSD Open Source license info
 *
 * Revision 1.4  2002/05/09 01:46:24  trey
 * added --lang=lisp option for xdr
 *
 * Revision 1.3  2002/02/14 21:46:29  reids
 * Incorporating various changes that Trey made in the FIRE version
 *
 * Revision 1.4  2001/11/27 03:26:05  trey
 * fixed line number at end
 *
 * Revision 1.3  2001/11/26 22:17:43  trey
 * fixed line directives bug
 *
 * Revision 1.2  2001/11/14 17:58:53  reids
 * Incorporating various changes that Trey made in the DIRA/FIRE versions.
 *
 * Revision 1.2  2001/11/06 22:01:52  trey
 * changed bool format for binary compatibility with C++ bool representation
 *
 * Revision 1.1  2001/03/16 17:56:03  reids
 * Release of Trey's code to generate IPC format strings from XDR definitions.
 *
 * Revision 1.8  2001/02/13 23:40:13  trey
 * fixed problem with variable-length array of strings
 *
 * Revision 1.7  2001/02/08 04:14:57  trey
 * added enumerated types and fixed C language output
 *
 * Revision 1.6  2001/02/08 00:41:58  trey
 * added external IPC format feature to xdrgen; we also now tag the generated file with a version string
 *
 * Revision 1.5  2001/02/06 15:19:34  trey
 * added macro define in C++ output (because you can concatentate string literals, but not function returns)
 *
 * Revision 1.4  2001/02/06 04:28:15  trey
 * fixed problem with output for string declarations
 *
 * Revision 1.3  2001/02/06 04:14:16  trey
 * example.xdr
 *
 * Revision 1.2  2001/02/06 02:01:55  trey
 * fixed bugs discovered while generating commonTypes message formats
 *
 * Revision 1.1  2001/02/05 21:10:49  trey
 * initial check-in
 *
 *
 ***************************************************************************/
