if ! $(AntlrRules_INCLUDED)

{

# *** TO DO:
# - In order to avoid repetitively regenerating java files,
#   rules should explicitly represent file names.

# AntlrGrammar ParserPrefix : grammar.g grammar.tree.g : grammar.package ;
rule AntlrGrammar
{
  local prefix = $(1) ;
  local grammar = $(2[1]) ;
  local grammar.tree = $(2[2]) ;
  local package = $(3) ;

  # Echo AntlrGrammar . $(prefix) . $(grammar) . $(grammar.tree) . $(package) ;

  local files = $(prefix)Lexer.java $(prefix)Parser.java $(prefix)TokenTypes.java $(prefix)TokenTypes.txt ;
  AntlrTool $(files) : $(grammar) : $(package) ;

  Depends $(files) : $(grammar) ;
  LocalClean $(files) ;
  
  if $(grammar.tree) 
  {
    local files.tree = $(prefix)TreeParser.java $(prefix)TreeParserTokenTypes.java $(prefix)TreeParserTokenTypes.txt ;
    AntlrTool $(files.tree) : $(grammar.tree) : $(package) ;

    Depends $(files.tree) : $(files) $(grammar.tree) ;
    LocalClean $(files.tree) ;
  }
}

rule AntlrGrammarArg
{
  local prefix = $(1) ;
  local grammar = $(2[1]) ;
  local grammar.tree = $(2[2]) ;
  local package = $(3) ;
  local java_src_dir = $(4) ;

  # Echo AntlrGrammarArg . $(prefix) . $(grammar) . $(grammar.tree) . $(package) . $(java_src_dir) ;

  local files = $(prefix)Lexer.java $(prefix)Parser.java $(prefix)TokenTypes.java $(prefix)TokenTypes.txt ;
  local files.tree = $(prefix)TreeParser.java $(prefix)TreeParserTokenTypes.java $(prefix)TreeParserTokenTypes.txt ;
  AntlrToolArg $(files) : $(grammar) : $(package) : $(java_src_dir) ;
  if $(files.tree) 
  {
    Depends $(files.tree) : $(files) ;
    AntlrToolArg $(files.tree) : $(grammar.tree) : $(package) : $(java_src_dir) ;
  }
}

rule AntlrTool
{
  local files = $(1) ;
  local grammar = $(2) ;
  local package = $(3) ;

  # Echo AntlrTool . $(files) . $(grammar) . $(package) ;

  local pathname = [ FDirName $(JAVA_SRC_DIR) [ FSplit "\\." : $(package) ] ] ;
  PATHNAME on $(files) = $(pathname) ;
  RELPATH on $(files) = [ FRelPath $(pathname) : $(PWD) ] ;
  SEARCH on $(grammar) += $(SEARCH_SOURCE) ;
  MakeLocate $(files) : $(pathname) ;
  RunAntlrTool $(files) : $(grammar) ;
}

rule AntlrToolArg
{
  local files = $(1) ;
  local grammar = $(2) ;
  local package = $(3) ;
  local java_src_dir = $(4) ;

  # Echo AntlrToolArg . $(files) . $(grammar) . $(package) . $(java_src_dir) ;

  local pathname = [ FDirName $(java_src_dir) [ FSplit "\\." : $(package) ] ] ;
  PATHNAME on $(files) = $(pathname) ;
  RELPATH on $(files) = [ FRelPath $(pathname) : $(PWD) ] ;
  SEARCH on $(grammar) += $(SEARCH_SOURCE) ;
  MakeLocate $(files) : $(pathname) ;
  RunAntlrTool $(files) : $(grammar) ;
}

# RunAntlrTool <Parser.java> <ParserTokenTypes.java> <ParserTokenTypes.txt> : <foo.antlr>
rule RunAntlrTool
{
  local files = $(1) ;
  local grammar = $(2) ;
  local package = $(3) ;

  # Echo RunAntlrTool . $(files) . $(grammar) ;

  Depends $(files) : $(grammar) ;
  LocalClean clean : $(files) ;
}

actions RunAntlrTool
{
  $(RM) -f $(1)
  "$(JAVA)" -cp $(ANTLR_JAR) antlr.Tool -o $(PATHNAME) $(2) 
# debug alternatives
#  "$(JAVA)" -cp $(ANTLR_JAR) antlr.Tool -o $(PATHNAME) -traceParser $(2)
#  "$(JAVA)" -cp $(ANTLR_JAR) antlr.Tool -o $(PATHNAME) -traceTreeParser $(2) 
#  "$(JAVA)" -cp $(ANTLR_JAR) antlr.Tool -o $(PATHNAME) -traceParser -traceTreeParser $(2)
}

AntlrRules_INCLUDED = TRUE ;

} # AntlrRules_INCLUDED
